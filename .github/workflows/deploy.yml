name: Déploiement Multi-Environnement (OIDC)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement à déployer'
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod
      branch:
        description: 'Branche Git à déployer'
        required: false
        default: dev
        type: string
      image_tag:
        description: 'Tag de l’image Docker à déployer'
        required: true
        default: latest
        type: string

#  repository_dispatch:
#    types: [deploy]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment }}

    steps:
      - name: Initialiser variables d'environnement
        id: vars
        env:
          ENV: ${{ github.event.inputs.environment || github.event.client_payload.environment }}
          BRANCH: ${{ github.event.inputs.branch || github.event.client_payload.branch }}
          IMAGE_TAG: ${{ github.event.inputs.image_tag || github.event.client_payload.image_tag }}
        run: |
          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

          echo "Variables d'environnement initialisées :"
          echo "- ENV=$ENV"
          echo "- BRANCH=$BRANCH"
          echo "- IMAGE_TAG=$IMAGE_TAG"

      - name: Checkout du code
        uses: actions/checkout@v3
        with:
          ref: ${{ env.BRANCH }}

      - name: Configurer AWS avec OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsECRRole
          aws-region: ca-central-1

      - name: Connexion à EKS (mise à jour kubeconfig)
        run: aws eks update-kubeconfig --region ca-central-1 --name mon-cluster

      - name: Installer Helm
        uses: azure/setup-helm@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Vérifier la présence de l'image Docker dans ECR
        run: |
          echo "Vérification de l'image $IMAGE_TAG dans ECR..."
          if ! aws ecr describe-images --repository-name touchtunes --image-ids imageTag="$IMAGE_TAG" --region ca-central-1; then
            echo "ERREUR : L'image Docker avec le tag '$IMAGE_TAG' n'existe PAS dans le dépôt ECR 'touchtunes'."
            exit 1
          fi

      - name: Déployer avec Helm
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ENV: ${{ env.ENV }}
        run: |
          helm upgrade --install backend ./charts \
            --namespace $ENV \
            --create-namespace \
            --values ./charts/values.yaml \
            --values ./charts/values-$ENV.yaml \
            --set image.repository="$AWS_ACCOUNT_ID.dkr.ecr.ca-central-1.amazonaws.com/touchtunes" \
            --set image.tag=$IMAGE_TAG  

      - name: Vérifier le statut des pods déployés
        run: |
          kubectl get pods -n $ENV
          kubectl describe deployment backend-deployment -n $ENV



#name: Déploiement Multi-Environnement (OIDC)
#
## Déclencheurs possibles : manuel (workflow_dispatch) ou via repository_dispatch (API)
#on:
#  workflow_dispatch:
#    inputs:
#      environment:
#        description: 'Environnement à déployer'
#        required: true
#        default: dev
#        type: choice
#        options:
#          - dev
#          - staging
#          - prod
#      branch:
#        description: 'Branche Git à déployer'
#        required: false
#        default: dev
#        type: string
#
#  repository_dispatch:
#    types: [deploy]
#
## Permissions pour utiliser OIDC et accéder au repo
#permissions:
#  id-token: write
#  contents: read
#
#jobs:
#  deploy:
#    runs-on: ubuntu-latest
#
#    # Nom de l'environnement GitHub (pour gestion secrets, protections, etc.)
#    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment }}
#
#    steps:
#      # Étape 1 : Initialiser les variables d’environnement à partir des inputs ou du payload dispatch
#      - name: Initialiser variables d'environnement
#        id: vars
#        env:
#          ENV: ${{ github.event.inputs.environment || github.event.client_payload.environment }}
#          BRANCH: ${{ github.event.inputs.branch || github.event.client_payload.branch }}
#          IMAGE_TAG: ${{ github.event.client_payload.image_tag }}
#        run: |
#          echo "ENV=$ENV" >> $GITHUB_ENV
#          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
#          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
#
#          echo "Variables d'environnement initialisées :"
#          echo "- ENV=$ENV"
#          echo "- BRANCH=$BRANCH"
#          echo "- IMAGE_TAG=$IMAGE_TAG"
#
#      # Étape 2 : Checkout du code à la branche spécifiée
#      - name: Checkout du code
#        uses: actions/checkout@v3
#        with:
#          ref: ${{ env.BRANCH }}
#
#      # Étape 3 : Configuration AWS via OIDC (pas besoin de secrets AWS statiques)
#      - name: Configurer AWS avec OIDC
#        uses: aws-actions/configure-aws-credentials@v2
#        with:
#          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-eks-role
#          aws-region: ca-central-1
#
#      # Étape 4 : Mise à jour du kubeconfig pour accéder à EKS
#      - name: Connexion à EKS (mise à jour kubeconfig)
#        run: aws eks update-kubeconfig --region ca-central-1 --name mon-cluster
#
#      # Étape 5 : Installer Helm (outil de gestion Kubernetes)
#      - name: Installer Helm
#        uses: azure/setup-helm@v3
#
#      # Étape 6 : Vérifier que l'image Docker avec le tag existe dans ECR
#      - name: Vérifier la présence de l'image Docker dans ECR
#        run: |
#          echo "Vérification de l'image $IMAGE_TAG dans ECR..."
#          if ! aws ecr describe-images --repository-name touchtunes --image-ids imageTag=$IMAGE_TAG --region ca-central-1; then
#            echo "ERREUR : L'image Docker avec le tag '$IMAGE_TAG' n'existe PAS dans le dépôt ECR 'touchtunes'."
#            echo "Veuillez vérifier que l'image a bien été poussée avant de déployer."
#            exit 1
#          fi
#
#      # Étape 7 : Déploiement avec Helm, injection des variables via env
#      - name: Déployer avec Helm
#        env:
#          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
#          IMAGE_TAG: ${{ env.IMAGE_TAG }}
#          ENV: ${{ env.ENV }}
#        run: |
#          echo "Déploiement sur l'environnement : $ENV"
#          echo "Tag image : $IMAGE_TAG"
#
#          helm upgrade --install microservice-a ./charts/microservice-a \
#            --namespace mon-namespace-$ENV \
#            --create-namespace \
#            --values ./charts/microservice-a/values.yaml \
#            --values ./charts/microservice-a/values-$ENV.yaml \
#            --set image.repository="$AWS_ACCOUNT_ID.dkr.ecr.ca-central-1.amazonaws.com/touchtunes" \
#            --set image.tag=$IMAGE_TAG
#
#      # Étape 8 : Vérifier le statut du déploiement et lister les pods
#      - name: Vérifier le statut des pods déployés
#        run: |
#          echo "Vérification des pods dans le namespace mon-namespace-$ENV..."
#          kubectl rollout status deployment/microservice-a -n mon-namespace-$ENV --timeout=120s
#          kubectl get pods -n mon-namespace-$ENV



#name: Déploiement Multi-Environnement (OIDC)
#
## Déclencheurs du workflow
#on:
#  workflow_dispatch:  # Déclenchement manuel depuis l'interface GitHub
#    inputs:
#      environment:  # Choix de l'environnement (dev, staging, prod)
#        description: 'Environnement à déployer'
#        required: true
#        default: dev
#        type: choice
#        options:
#          - dev
#          - staging
#          - prod
#      branch:   # Branche Git à déployer (ex: dev, main, staging)
#        description: 'Branche Git à déployer'
#        required: false
#        default: dev
#        type: string
#
#  repository_dispatch: # Déclenchement par un autre workflow via API (ex: CI)
#    types: [deploy]
#
## Permissions nécessaires pour OIDC
#permissions:
#  id-token: write    # Obligatoire pour s'authentifier via OIDC (sans clé AWS)
#  contents: read     # Pour pouvoir lire le repo Git (checkout)
#
#jobs:
#  deploy:
#    runs-on: ubuntu-latest   # Agent GitHub qui exécutera le job
#
#    # Nom de l'environnement GitHub (pour gérer secrets & protections)
#    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment }}
#
#    steps:
#      # Étape 1 : Récupération des variables d'entrée ou payload de repository_dispatch
#      - name: Déterminer les paramètres
#        id: vars
#        run: |
#          # Récupération de l'environnement (manuel ou via dispatch)
#          ENV="${{ github.event.inputs.environment || github.event.client_payload.environment }}"
#          # Récupération de la branche git (manuel ou via dispatch)
#          BRANCH="${{ github.event.inputs.branch || github.event.client_payload.branch }}"
#          # Récupération du tag image uniquement via repository_dispatch (pas dispo dans manuel)
#          IMAGE_TAG="${{ github.event.client_payload.image_tag }}"
#
#          # Export des variables dans l'environnement d'exécution GitHub
#          echo "ENV=$ENV" >> $GITHUB_ENV
#          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
#          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
#
#          echo "Environnement : $ENV"
#          echo "Branche : $BRANCH"
#          echo "Tag image : $IMAGE_TAG"
#
#      # Étape 2 : Checkout du code source (chart Helm)
#      - name: Checkout du code
#        uses: actions/checkout@v3
#        with:
#          ref: ${{ env.BRANCH }}
#
#      # Étape 3 : Configuration AWS via OIDC (pas besoin de secrets AWS dans GitHub)
#      - name: Configurer AWS avec OIDC
#        uses: aws-actions/configure-aws-credentials@v2
#        with:
#          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-eks-role
#          aws-region: ca-central-1
#
#      # Étape 4 : Connexion au cluster EKS (mise à jour du kubeconfig)
#      - name: Connexion à EKS
#        run: aws eks update-kubeconfig --region ca-central-1 --name mon-cluster
#
#      # Étape 5 : Installer Helm (outil de déploiement Kubernetes)
#      - name: Installer Helm
#        uses: azure/setup-helm@v3
#
#      # Étape 6 : Vérifier la présence de l'image Docker dans ECR
#      - name: Vérifier la présence de l'image Docker dans ECR
#        id: check-image
#        run: |
#          echo "Vérification de l'image $IMAGE_TAG dans ECR..."
#          if ! aws ecr describe-images --repository-name touchtunes --image-ids imageTag=$IMAGE_TAG --region ca-central-1; then
#            echo "ERREUR : L'image Docker avec le tag '$IMAGE_TAG' n'existe PAS dans le dépôt ECR 'touchtunes'."
#            echo "Veuillez vérifier que l'image a bien été poussée avant de déployer."
#            exit 1
#          fi
#
#      # Étape 7 : Déploiement avec Helm
#      - name: Déployer avec Helm
#        run: |
#
#          echo "Déploiement sur l'environnement : $ENV"
#          echo "Tag image : $IMAGE_TAG"
#
#          # Commande Helm upgrade/install
#          helm upgrade --install microservice-a ./charts/microservice-a \
#            --namespace mon-namespace-$ENV \
#            --create-namespace \
#            --values ./charts/microservice-a/values.yaml \
#            --values ./charts/microservice-a/values-$ENV.yaml \
#            --set image.repository="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ca-central-1.amazonaws.com/touchtunes" \
#            --set image.tag=$IMAGE_TAG
#
#
#      - name: Vérifier le statut des pods déployés
#        run: |
#          echo "Vérification des pods dans le namespace mon-namespace-$ENV..."
#          kubectl rollout status deployment/microservice-a -n mon-namespace-$ENV --timeout=120s
#          kubectl get pods -n mon-namespace-$ENV
